```{Rcpp}
#include <Rcpp.h>
#include <string>
#include <vector>
using namespace std;
using namespace Rcpp;

// [[Rcpp::export]]
double needleman_wunsch_score(const string &sequence1, const string &sequence2,
                               int matchScore=1, int mismatchPenalty=-2, int gapPenalty=-2) {  
  size_t m = sequence1.size();
  size_t n = sequence2.size();  
    
    // Initialize the dynamic programming matrix  
    vector<vector<int>> dpMatrix(m + 1, vector<int>(n + 1, 0));  
    
    // Initialize the first row and column with gap penalties  
    for (size_t i = 1; i <= m; ++i) {  
        dpMatrix[i][0] = dpMatrix[i - 1][0] + gapPenalty;  
    }  
    
    for (size_t j = 1; j <= n; ++j) {  
        dpMatrix[0][j] = dpMatrix[0][j - 1] + gapPenalty;  
    }  
    
    // Fill the dynamic programming matrix  
    for (size_t i = 1; i <= m; ++i) {  
        for (size_t j = 1; j <= n; ++j) {  
            int match = dpMatrix[i - 1][j - 1] + 
                       (sequence1[i - 1] == sequence2[j - 1] ? matchScore : mismatchPenalty);  
            int gap1 = dpMatrix[i - 1][j] + gapPenalty;  
            int gap2 = dpMatrix[i][j - 1] + gapPenalty;  
            
            dpMatrix[i][j] = max({match, gap1, gap2});  
        }  
    }  
    
    // Backtrack to count matches
    int i = m, j = n;  
    int matches = 0;
    int totalLength = 0;
    
    while (i > 0 || j > 0) {  
        ++totalLength;
        if (i > 0 && j > 0 && dpMatrix[i][j] == dpMatrix[i - 1][j - 1] + 
            (sequence1[i - 1] == sequence2[j - 1] ? matchScore : mismatchPenalty)) {  
            if (sequence1[i - 1] == sequence2[j - 1]) {
                ++matches;
            }
            --i;  
            --j;  
        } else if (i > 0 && dpMatrix[i][j] == dpMatrix[i - 1][j] + gapPenalty) {  
            --i;  
        } else {  
            --j;  
        }  
    }  
    
    return static_cast<double>(matches) / totalLength;
}

// [[Rcpp::export]]
NumericMatrix calculateSimilarityMatrix(CharacterVector sequences) {
    size_t n = sequences.length();
    NumericMatrix similarityMatrix(n, n);
    
    // Calculate pairwise similarities
    for(size_t i = 0; i < n; ++i) {
        for(size_t j = i; j < n; ++j) {
            if(i == j) {
                similarityMatrix(i, j) = 1.0;  // Diagonal elements
                continue;
            }
            
            // Convert CharacterVector elements to std::string
            string seq1 = as<string>(sequences[i]);
            string seq2 = as<string>(sequences[j]);
            
            // Get similarity score directly
            double similarity = needleman_wunsch_score(seq1, seq2);
            
            // Fill both upper and lower triangles
            similarityMatrix(i, j) = similarity;
            similarityMatrix(j, i) = similarity;
        }
    }
    
    // Create numeric labels 1,2,3...
    CharacterVector labels(n);
    for(size_t i = 0; i < n; ++i) {
        labels[i] = std::to_string(i + 1);
    }
    
    // Add dimension names using numeric labels
    similarityMatrix.attr("dimnames") = List::create(labels, labels);
    
    return similarityMatrix;
}
```

```{Rcpp}
#include <Rcpp.h>
#include <string>
#include <vector>
using namespace std;
using namespace Rcpp;

// [[Rcpp::export]]
List needleman_wunsch(const string &sequence1, const string &sequence2, int matchScore, int mismatchPenalty, int gapPenalty) {  
    size_t m = sequence1.size();
    size_t n = sequence2.size();  
  
    // Initialize the dynamic programming matrix  
    vector<vector<int>> dpMatrix(m + 1, vector<int>(n + 1, 0));  
  
    // Initialize the first row and column with gap penalties  
    for (int i = 1; i <= m; ++i) {  
        dpMatrix[i][0] = dpMatrix[i - 1][0] + gapPenalty;  
    }  
  
    for (int j = 1; j <= n; ++j) {  
        dpMatrix[0][j] = dpMatrix[0][j - 1] + gapPenalty;  
    }  
  
    // Fill the dynamic programming matrix  
    for (int i = 1; i <= m; ++i) {  
        for (int j = 1; j <= n; ++j) {  
            int match = dpMatrix[i - 1][j - 1] + (sequence1[i - 1] == sequence2[j - 1] ? matchScore : mismatchPenalty);  
            int gap1 = dpMatrix[i - 1][j] + gapPenalty;  
            int gap2 = dpMatrix[i][j - 1] + gapPenalty;  
  
            dpMatrix[i][j] = max({match, gap1, gap2});  
        }  
    }  
  
    // Backtrack to find the optimal alignment  
    int i = m, j = n;  
    string align1, align2;  
  
    while (i > 0 || j > 0) {  
        if (i > 0 && j > 0 && dpMatrix[i][j] == dpMatrix[i - 1][j - 1] + (sequence1[i - 1] == sequence2[j - 1] ? matchScore : mismatchPenalty)) {  
            align1 = sequence1[i - 1] + align1;  
            align2 = sequence2[j - 1] + align2;  
            --i;  
            --j;  
        } else if (i > 0 && dpMatrix[i][j] == dpMatrix[i - 1][j] + gapPenalty) {  
            align1 = sequence1[i - 1] + align1;  
            align2 = '-' + align2;  
            --i;  
        } else {  
            align1 = '-' + align1;  
            align2 = sequence2[j - 1] + align2;  
            --j;  
        }  
    }  
  return List::create(Named("alignment1") = align1,
                      Named("alignment2") = align2,
                      Named("score") = dpMatrix[n][m]);
}

```

```{r}
library(digest)

# Function to generate k-mers from an aligned sequence
generate_kmers = function(sequence, k) {
    kmers = c()
    n = nchar(sequence)
    for (i in 1:(n - k + 1)) {
        kmer = substr(sequence, i, i + k - 1)
        # Skip k-mers containing gaps
        if (!grepl("-", kmer)) {
            kmers = c(kmers, kmer)
        }
    }
    return(unique(kmers))
}

# Function to compute MinHash signature
compute_minhash_signature = function(kmers, num_hashes = 100) {
    signature = numeric(num_hashes)
    universe = unique(kmers)
    for (i in 1:num_hashes) {
        # Use murmur32 algorithm with seed
        hashed_values = sapply(kmers, function(kmer) {
            # Get the hash value as a hexadecimal string
            hash_hex = digest(kmer, algo = "murmur32", seed = i)
            # Convert hexadecimal string to numeric value
            hash_num = as.numeric(paste0("0x", hash_hex))
            return(hash_num)
        })
        signature[i] = min(hashed_values, na.rm = TRUE)
    }
    return(signature)
}

# Function to compute similarity between two signatures
compute_minhash_similarity = function(sig1, sig2) {
    return(sum(sig1 == sig2) / length(sig1))
}

# Function to compute the similarity matrix
compute_similarity_matrix_minhash = function(sequences, k = 3, num_hashes = 100) {
    n = length(sequences)
    similarity_matrix = matrix(0, nrow = n, ncol = n)
    colnames(similarity_matrix) = rownames(similarity_matrix) = sequences

    # Parameters for alignment
    match_score = 1
    mismatch_penalty = -1
    gap_penalty = -1

    # Store MinHash signatures for each sequence
    minhash_signatures = vector("list", n)

    for (i in 1:n) {
        # Align each sequence with itself
        result = needleman_wunsch(sequences[i], sequences[i], match_score, mismatch_penalty, gap_penalty)
        aligned_seq = result$alignment1
        # Generate k-mers
        kmers = generate_kmers(aligned_seq, k)
        # Compute MinHash signature
        minhash_signatures[[i]] = compute_minhash_signature(kmers, num_hashes)
    }

    # Compute pairwise similarities
    for (i in 1:n) {
        for (j in i:n) {
            if (i == j) {
                similarity_matrix[i, j] = 1  # Similarity with itself is 1
            } else {
                sim = compute_minhash_similarity(minhash_signatures[[i]], minhash_signatures[[j]])
                similarity_matrix[i, j] = sim
                similarity_matrix[j, i] = sim
            }
        }
    }
    return(similarity_matrix)
}
```

```{r}
# Compute the similarity matrix using MinHash
similarity_matrix_minhash = compute_similarity_matrix_minhash(peptides, k = 3, num_hashes = 100)
similarity_matrix_minhash[1,]
```

```{r}
s1 = "ATGAGTCTCTCTGATAAGGACAAGGCTGCTGTGAAAGCCCTATGG"
  s2 = "CTGTCTCCTGCCGACAAGACCAACGTCAAGGCCGCCTGGGGTAAG"
s3 = "TGAGTCTCTCTGPTAAGGAUSAGGCTGAGGTGAAAGUCCCTATGG"
match_score = 1
mismatch_penalty = -2
gap_penalty = -2
result = needleman_wunsch(s1, s3, match_score, mismatch_penalty, gap_penalty)

alignment1 = result$alignment1
alignment2 = result$alignment2

# Initialize counters
num_identities <- 0
num_gaps <- 0

# Iterate over sequences
for (i in 1:nchar(alignment1)) {
    char1 <- substr(alignment1, i, i)
    char2 <- substr(alignment2, i, i)
    
    if (char1 == "-" || char2 == "-") {
        num_gaps <- num_gaps + 1
    } else if (char1 == char2) {
        num_identities <- num_identities + 1
    }
}

# Output
nchar(s1)
leng = nchar(alignment1)
cat("Number of identities:", num_identities, "\n")
cat("Number of gaps:", num_gaps, "\n")

alignment1
alignment2

num_identities / leng
```

```{r}
s1 = "RRAVELQTVAFP"
s2 = "PPPSYETVMAAA"
s3 = "TPPPSYETVMAA"
data = read.csv("C:/Users/syl05/OneDrive/Desktop/UMICH/FALL 2024/Biostat 615/DynaAlign/data/testData/Adenovirus_IgG_191213_27Jan2023_MDS_Long_COVID_19_vs_MECFS_Case_Serum.wDescr.sorted.csv")
peptides = data$PROBE_SEQUENCE
mat = calculateSimilarityMatrix(peptides[1:10])
mat
# mat[1,]
mat = minhash_similarity_matrix(peptides[1:10])
mat
# mat[1,]
# calculateSimilarityMatrix(c(s1,s2,s3))
# minhash_similarity_matrix(c(s1,s2,s3))
```

```{Rcpp}
#include <Rcpp.h>
#include <string>
#include <vector>
using namespace std;
using namespace Rcpp;

// MurmurHash3 implementation
uint32_t murmur3_32(const char* key, size_t len, uint32_t seed) {
    static const uint32_t c1 = 0xcc9e2d51;
    static const uint32_t c2 = 0x1b873593;
    static const uint32_t r1 = 15;
    static const uint32_t r2 = 13;
    static const uint32_t m = 5;
    static const uint32_t n = 0xe6546b64;

    uint32_t hash = seed;

    const int nblocks = len / 4;
    const uint32_t* blocks = (const uint32_t*)(key);

    for(int i = 0; i < nblocks; i++) {
        uint32_t k = blocks[i];
        k *= c1;
        k = (k << r1) | (k >> (32 - r1));
        k *= c2;
        hash ^= k;
        hash = ((hash << r2) | (hash >> (32 - r2))) * m + n;
    }

    const uint8_t* tail = (const uint8_t*)(key + nblocks * 4);
    uint32_t k1 = 0;

    switch(len & 3) {
        case 3: k1 ^= tail[2] << 16;
        case 2: k1 ^= tail[1] << 8;
        case 1: k1 ^= tail[0];
                k1 *= c1;
                k1 = (k1 << r1) | (k1 >> (32 - r1));
                k1 *= c2;
                hash ^= k1;
    }

    hash ^= len;
    hash ^= (hash >> 16);
    hash *= 0x85ebca6b;
    hash ^= (hash >> 13);
    hash *= 0xc2b2ae35;
    hash ^= (hash >> 16);

    return hash;
}

// Hash family class for multiple hash functions
class HashFamily {
private:
    vector<uint32_t> seeds;
    
public:
    HashFamily(int num_hash) {
        seeds.resize(num_hash);
        for(int i = 0; i < num_hash; ++i) {
            seeds[i] = i + 1;  // Simple seed generation
        }
    }
    
    uint32_t hash(const string& s, int index) {
        return murmur3_32(s.c_str(), s.length(), seeds[index]);
    }
};

// Generate k-mers from a sequence
vector<string> generate_kmers(const string& seq, int k) {
    vector<string> kmers;
    if (seq.length() >= k) {
        for(size_t i = 0; i <= seq.length() - k; ++i) {
            kmers.push_back(seq.substr(i, k));
        }
    }
    return kmers;
}

// [[Rcpp::export]]
NumericMatrix minhash_similarity_matrix(CharacterVector sequences, int k = 2, int num_hash = 50) {
    size_t n = sequences.length();
    NumericMatrix similarityMatrix(n, n);
    
    // Initialize hash family
    HashFamily hash_family(num_hash);
    
    // Store signatures for each sequence
    vector<vector<uint32_t>> signatures(n, vector<uint32_t>(num_hash, UINT32_MAX));
    
    // Generate signatures
    for(size_t i = 0; i < n; ++i) {
        string seq = as<string>(sequences[i]);
        vector<string> kmers = generate_kmers(seq, k);
        
        // For each k-mer, update signature
        for(const string& kmer : kmers) {
            for(int h = 0; h < num_hash; ++h) {
                uint32_t hash_value = hash_family.hash(kmer, h);
                signatures[i][h] = min(signatures[i][h], hash_value);
            }
        }
    }
    
    // Calculate similarities
    for(size_t i = 0; i < n; ++i) {
        similarityMatrix(i,i) = 1.0;  // Diagonal elements
        for(size_t j = i+1; j < n; ++j) {
            int matches = 0;
            for(int h = 0; h < num_hash; ++h) {
                if(signatures[i][h] == signatures[j][h]) {
                    ++matches;
                }
            }
            double similarity = static_cast<double>(matches) / num_hash;
            similarityMatrix(i,j) = similarity;
            similarityMatrix(j,i) = similarity;
        }
    }
    
    // Add dimension names (1,2,3...)
    CharacterVector labels(n);
    for(size_t i = 0; i < n; ++i) {
        labels[i] = to_string(i + 1);
    }
    similarityMatrix.attr("dimnames") = List::create(labels, labels);
    
    return similarityMatrix;
}
```

```{Rcpp}
// minhash.cpp

#include <Rcpp.h>
#include <unordered_set>
#include <vector>
#include <string>
#include <climits>

// [[Rcpp::plugins(cpp11)]]

using namespace Rcpp;

// FNV-1a 32-bit hash function
unsigned int fnv1aHash(const std::string &str, unsigned int seed) {
    const unsigned int fnv_prime = 0x01000193; // 16777619
    unsigned int hash = 0x811C9DC5;            // 2166136261

    // Incorporate the seed into the initial hash
    hash ^= seed;

    for (char c : str) {
        hash ^= static_cast<unsigned char>(c);
        hash *= fnv_prime;
    }
    return hash;
}

// [[Rcpp::export]]
std::vector< std::vector<unsigned int> > computeMinHashSignatures(
    const std::vector< std::vector<std::string> > &all_kmers,
    int num_hashes) {
    int num_sequences = all_kmers.size();
    std::vector< std::vector<unsigned int> > signatures(
        num_sequences, std::vector<unsigned int>(num_hashes, UINT_MAX)
    );

    for (int i = 0; i < num_sequences; ++i) {
        // Use a set to avoid duplicate k-mers
        std::unordered_set<std::string> kmers(all_kmers[i].begin(), all_kmers[i].end());
        for (int n = 0; n < num_hashes; ++n) {
            for (const auto &kmer : kmers) {
                unsigned int hash_value = fnv1aHash(kmer, n);
                if (hash_value < signatures[i][n]) {
                    signatures[i][n] = hash_value;
                }
            }
        }
    }
    return signatures;
}

```

```{r}
# Input peptide sequences
peptides <- c(
  s1 = "RRAVELQTVAFP",
  s2 = "RAVELQTVAFPA",
  s3 = "RCVVAFPAVELB"
)
data = read.csv("C:/Users/syl05/OneDrive/Desktop/UMICH/FALL 2024/Biostat 615/DynaAlign/data/testData/Adenovirus_IgG_191213_27Jan2023_MDS_Long_COVID_19_vs_MECFS_Case_Serum.wDescr.sorted.csv")
peptides = data$PROBE_SEQUENCE
peptides = peptides[90:100]
# Function to generate k-mers from a sequence
generate_kmers <- function(sequence, k) {
  n <- nchar(sequence)
  kmers <- substring(sequence, 1:(n - k + 1), k:n)
  return(kmers)
}
# Set the value of k for k-mers
k <- 2  # For example, trigrams

# Generate k-mers for each sequence
all_kmers <- lapply(peptides, generate_kmers, k = k)
# Number of hash functions
num_hashes <- 50  # Adjust as needed for accuracy

# Compute MinHash signatures using the Rcpp function
signatures <- computeMinHashSignatures(all_kmers, num_hashes)
# Function to compute similarity between two signatures
compute_similarity <- function(sig1, sig2) {
  return(mean(sig1 == sig2))
}

# Initialize similarity matrix
num_sequences <- length(peptides)
similarity_matrix <- matrix(0, nrow = num_sequences, ncol = num_sequences)
rownames(similarity_matrix) <- names(peptides)
colnames(similarity_matrix) <- names(peptides)

# Compute pairwise similarities
for (i in 1:num_sequences) {
  for (j in i:num_sequences) {
    sim <- compute_similarity(signatures[[i]], signatures[[j]])
    similarity_matrix[i, j] <- sim
    similarity_matrix[j, i] <- sim  # Symmetric matrix
  }
}

# # View the similarity matrix
# print(similarity_matrix)
similarity_matrix
```

```{r}
similarity_matrix[1,]
```

```{r}
peptides[1:10]
is.character(peptides)
```

