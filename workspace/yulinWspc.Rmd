```{Rcpp}
#include <Rcpp.h>
#include <string>
#include <vector>
using namespace std;
using namespace Rcpp;

// [[Rcpp::export]]
double needleman_wunsch_score(const string &sequence1, const string &sequence2,
                               int matchScore=1, int mismatchPenalty=-2, int gapPenalty=-2) {  
  size_t m = sequence1.size();
  size_t n = sequence2.size();  
    
    // Initialize the dynamic programming matrix  
    vector<vector<int>> dpMatrix(m + 1, vector<int>(n + 1, 0));  
    
    // Initialize the first row and column with gap penalties  
    for (size_t i = 1; i <= m; ++i) {  
        dpMatrix[i][0] = dpMatrix[i - 1][0] + gapPenalty;  
    }  
    
    for (size_t j = 1; j <= n; ++j) {  
        dpMatrix[0][j] = dpMatrix[0][j - 1] + gapPenalty;  
    }  
    
    // Fill the dynamic programming matrix  
    for (size_t i = 1; i <= m; ++i) {  
        for (size_t j = 1; j <= n; ++j) {  
            int match = dpMatrix[i - 1][j - 1] + 
                       (sequence1[i - 1] == sequence2[j - 1] ? matchScore : mismatchPenalty);  
            int gap1 = dpMatrix[i - 1][j] + gapPenalty;  
            int gap2 = dpMatrix[i][j - 1] + gapPenalty;  
            
            dpMatrix[i][j] = max({match, gap1, gap2});  
        }  
    }  
    
    // Backtrack to count matches
    int i = m, j = n;  
    int matches = 0;
    int totalLength = 0;
    
    while (i > 0 || j > 0) {  
        ++totalLength;
        if (i > 0 && j > 0 && dpMatrix[i][j] == dpMatrix[i - 1][j - 1] + 
            (sequence1[i - 1] == sequence2[j - 1] ? matchScore : mismatchPenalty)) {  
            if (sequence1[i - 1] == sequence2[j - 1]) {
                ++matches;
            }
            --i;  
            --j;  
        } else if (i > 0 && dpMatrix[i][j] == dpMatrix[i - 1][j] + gapPenalty) {  
            --i;  
        } else {  
            --j;  
        }  
    }  
    
    return static_cast<double>(matches) / totalLength;
}

// [[Rcpp::export]]
NumericMatrix calculateSimilarityMatrix2(CharacterVector sequences) {
    size_t n = sequences.length();
    NumericMatrix similarityMatrix(n, n);
    
    // Calculate pairwise similarities
    for(size_t i = 0; i < n; ++i) {
        for(size_t j = i; j < n; ++j) {
            if(i == j) {
                similarityMatrix(i, j) = 1.0;  // Diagonal elements
                continue;
            }
            
            // Convert CharacterVector elements to std::string
            string seq1 = as<string>(sequences[i]);
            string seq2 = as<string>(sequences[j]);
            
            // Get similarity score directly
            double similarity = needleman_wunsch_score(seq1, seq2);
            
            // Fill both upper and lower triangles
            similarityMatrix(i, j) = similarity;
            similarityMatrix(j, i) = similarity;
        }
    }
    
    // Create numeric labels 1,2,3...
    CharacterVector labels(n);
    for(size_t i = 0; i < n; ++i) {
        labels[i] = std::to_string(i + 1);
    }
    
    // Add dimension names using numeric labels
    similarityMatrix.attr("dimnames") = List::create(labels, labels);
    
    return similarityMatrix;
}
```

```{Rcpp newest version PSA}
#include <Rcpp.h>
#include <string>
#include <vector>
#include <map>
#include <algorithm>
#include <limits>

using namespace std;
using namespace Rcpp;

// Amino acid to index mapping
const map<char, int> aa_to_index = {
   {'A', 0}, {'R', 1}, {'N', 2}, {'D', 3}, {'C', 4},
   {'Q', 5}, {'E', 6}, {'G', 7}, {'H', 8}, {'I', 9},
   {'L',10}, {'K',11}, {'M',12}, {'F',13}, {'P',14},
   {'S',15}, {'T',16}, {'W',17}, {'Y',18}, {'V',19},
   {'B',20}, {'Z',21}, {'X',22}, {'*', 23}
};

const int BLOSUM62[24][24] = {
   { 4,-1,-2,-2, 0,-1,-1, 0,-2,-1,-1,-1,-1,-2,-1, 1, 0,-3,-2, 0,-2,-1, 0,-4}, // A
   {-1, 5, 0,-2,-3, 1, 0,-2, 0,-3,-2, 2,-1,-3,-2,-1,-1,-3,-2,-3,-1, 0,-1,-4}, // R
   {-2, 0, 6, 1,-3, 0, 0, 0, 1,-3,-3, 0,-2,-3,-2, 1, 0,-4,-2,-3, 3, 0,-1,-4}, // N
   {-2,-2, 1, 6,-3, 0, 2,-1,-1,-3,-4,-1,-3,-3,-1, 0,-1,-4,-3,-3, 4, 1,-1,-4}, // D
   { 0,-3,-3,-3, 9,-3,-4,-3,-3,-1,-1,-3,-1,-2,-3,-1,-1,-2,-2,-1,-3,-3,-2,-4}, // C
   {-1, 1, 0, 0,-3, 5, 2,-2, 0,-3,-2, 1, 0,-3,-1, 0,-1,-2,-1,-2, 0, 3,-1,-4}, // Q
   {-1, 0, 0, 2,-4, 2, 5,-2, 0,-3,-3, 1,-2,-3,-1, 0,-1,-3,-2,-2, 1, 4,-1,-4}, // E
   { 0,-2, 0,-1,-3,-2,-2, 6,-2,-4,-4,-2,-3,-3,-2, 0,-2,-2,-3,-3,-1,-2,-1,-4}, // G
   {-2, 0, 1,-1,-3, 0, 0,-2, 8,-3,-3,-1,-2,-1,-2,-1,-2,-2, 2,-3, 0, 0,-1,-4}, // H
   {-1,-3,-3,-3,-1,-3,-3,-4,-3, 4, 2,-3, 1, 0,-3,-2,-1,-3,-1, 3,-3,-3,-1,-4}, // I
   {-1,-2,-3,-4,-1,-2,-3,-4,-3, 2, 4,-2, 2, 0,-3,-2,-1,-2,-1, 1,-4,-3,-1,-4}, // L
   {-1, 2, 0,-1,-3, 1, 1,-2,-1,-3,-2, 5,-1,-3,-1, 0,-1,-3,-2,-2, 0, 1,-1,-4}, // K
   {-1,-1,-2,-3,-1, 0,-2,-3,-2, 1, 2,-1, 5, 0,-2,-1,-1,-1,-1, 1,-3,-1,-1,-4}, // M
   {-2,-3,-3,-3,-2,-3,-3,-3,-1, 0, 0,-3, 0, 6,-4,-2,-2, 1, 3,-1,-3,-3,-1,-4}, // F
   {-1,-2,-2,-1,-3,-1,-1,-2,-2,-3,-3,-1,-2,-4, 7,-1,-1,-4,-3,-2,-2,-1,-2,-4}, // P
   { 1,-1, 1, 0,-1, 0, 0, 0,-1,-2,-2, 0,-1,-2,-1, 4, 1,-3,-2,-2, 0, 0, 0,-4}, // S
   { 0,-1, 0,-1,-1,-1,-1,-2,-2,-1,-1,-1,-1,-2,-1, 1, 5,-2,-2, 0,-1,-1, 0,-4}, // T
   {-3,-3,-4,-4,-2,-2,-3,-2,-2,-3,-2,-3,-1, 1,-4,-3,-2,11, 2,-3,-4,-3,-2,-4}, // W
   {-2,-2,-2,-3,-2,-1,-2,-3, 2,-1,-1,-2,-1, 3,-3,-2,-2, 2, 7,-1,-3,-2,-1,-4}, // Y
   { 0,-3,-3,-3,-1,-2,-2,-3,-3, 3, 1,-2, 1,-1,-2,-2, 0,-3,-1, 4,-3,-2,-1,-4}, // V
   {-2,-1, 3, 4,-3, 0, 1,-1, 0,-3,-4, 0,-3,-3,-2, 0,-1,-4,-3,-3, 4, 1,-1,-4}, // B
   {-1, 0, 0, 1,-3, 3, 4,-2, 0,-3,-3, 1,-1,-3,-1, 0,-1,-3,-2,-2, 1, 4,-1,-4}, // Z
   { 0,-1,-1,-1,-2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-2, 0, 0,-2,-1,-1,-1,-1,-1,-4}, // X
   {-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4,-4, 1}  // *
};


const int BLOSUM45[24][24] = {
   { 5,-2,-1,-2,-1,-1,-1, 0,-2,-1,-1,-1,-1,-2,-1, 1, 0,-2,-2, 0,-1,-1, 0,-5}, 
   {-2, 7, 0,-1,-3, 1, 0,-2, 0,-3,-2, 3,-1,-2,-2,-1,-1,-2,-1,-2,-1, 0,-1,-5},
   {-1, 0, 6, 2,-2, 0, 0, 0, 1,-2,-3, 0,-2,-2,-2, 1, 0,-4,-2,-3, 4, 0,-1,-5},
   {-2,-1, 2, 7,-3, 0, 2,-1, 0,-4,-3, 0,-3,-4,-1, 0,-1,-4,-2,-3, 5, 1,-1,-5},
   {-1,-3,-2,-3,12,-3,-3,-3,-3,-3,-2,-3,-2,-2,-4,-1,-1,-5,-3,-1,-2,-3,-2,-5},
   {-1, 1, 0, 0,-3, 6, 2,-2, 1,-2,-2, 1, 0,-4,-1, 0,-1,-2,-1,-3, 0, 4,-1,-5},
   {-1, 0, 0, 2,-3, 2, 6,-2, 0,-3,-2, 1,-2,-3, 0, 0,-1,-3,-2,-3, 1, 4,-1,-5},
   { 0,-2, 0,-1,-3,-2,-2, 7,-2,-4,-3,-2,-2,-3,-2, 0,-2,-2,-3,-3,-1,-2,-1,-5},
   {-2, 0, 1, 0,-3, 1, 0,-2,10,-3,-2,-1, 0,-2,-2,-1,-2,-3, 2,-3, 0, 0,-1,-5},
   {-1,-3,-2,-4,-3,-2,-3,-4,-3, 5, 2,-3, 2, 0,-2,-2,-1,-2, 0, 3,-3,-3,-1,-5},
   {-1,-2,-3,-3,-2,-2,-2,-3,-2, 2, 5,-3, 2, 1,-3,-3,-1,-2, 0, 1,-3,-2,-1,-5},
   {-1, 3, 0, 0,-3, 1, 1,-2,-1,-3,-3, 5,-1,-3,-1,-1,-1,-2,-1,-2, 0, 1,-1,-5},
   {-1,-1,-2,-3,-2, 0,-2,-2, 0, 2, 2,-1, 6, 0,-2,-2,-1,-2, 0, 1,-2,-1,-1,-5},
   {-2,-2,-2,-4,-2,-4,-3,-3,-2, 0, 1,-3, 0, 8,-3,-2,-1, 1, 3, 0,-3,-3,-1,-5},
   {-1,-2,-2,-1,-4,-1, 0,-2,-2,-2,-3,-1,-2,-3, 9,-1,-1,-3,-3,-3,-2,-1,-1,-5},
   { 1,-1, 1, 0,-1, 0, 0, 0,-1,-2,-3,-1,-2,-2,-1, 4, 2,-4,-2,-1, 0, 0, 0,-5},
   { 0,-1, 0,-1,-1,-1,-1,-2,-2,-1,-1,-1,-1,-1,-1, 2, 5,-3,-1, 0, 0,-1, 0,-5},
   {-2,-2,-4,-4,-5,-2,-3,-2,-3,-2,-2,-2,-2, 1,-3,-4,-3,15, 3,-3,-4,-2,-2,-5},
   {-2,-1,-2,-2,-3,-1,-2,-3, 2, 0, 0,-1, 0, 3,-3,-2,-1, 3, 8,-1,-2,-2,-1,-5},
   { 0,-2,-3,-3,-1,-3,-3,-3,-3, 3, 1,-2, 1, 0,-3,-1, 0,-3,-1, 5,-3,-3,-1,-5},
   {-1,-1, 4, 5,-2, 0, 1,-1, 0,-3,-3, 0,-2,-3,-2, 0, 0,-4,-2,-3, 5, 2,-1,-5},
   {-1, 0, 0, 1,-3, 4, 4,-2, 0,-3,-2, 1,-1,-3,-1, 0,-1,-2,-2,-3, 2, 4,-1,-5},
   { 0,-1,-1,-1,-2,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1, 0, 0,-2,-1,-1,-1,-1,-1,-5},
   {-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5, 1}
};


const int BLOSUM50[24][24] = {
   { 5,-2,-1,-2,-1,-1,-1, 0,-2,-1,-2,-1,-1,-3,-1, 1, 0,-3,-2, 0,-2,-1,-1,-5},
   {-2, 7,-1,-2,-4, 1, 0,-3, 0,-4,-3, 3,-2,-3,-3,-1,-1,-3,-1,-3,-1, 0,-1,-5},
   {-1,-1, 7, 2,-2, 0, 0, 0, 1,-3,-4, 0,-2,-4,-2, 1, 0,-4,-2,-3, 4, 0,-1,-5},
   {-2,-2, 2, 8,-4, 0, 2,-1,-1,-4,-4,-1,-4,-5,-1, 0,-1,-5,-3,-4, 5, 1,-1,-5},
   {-1,-4,-2,-4,13,-3,-3,-3,-3,-2,-2,-3,-2,-2,-4,-1,-1,-5,-3,-1,-3,-3,-2,-5},
   {-1, 1, 0, 0,-3, 7, 2,-2, 1,-3,-2, 2, 0,-4,-1, 0,-1,-1,-1,-3, 0, 4,-1,-5},
   {-1, 0, 0, 2,-3, 2, 6,-3, 0,-4,-3, 1,-2,-3,-1,-1,-1,-3,-2,-3, 1, 5,-1,-5},
   { 0,-3, 0,-1,-3,-2,-3, 8,-2,-4,-4,-2,-3,-4,-2, 0,-2,-3,-3,-4,-1,-2,-2,-5},
   {-2, 0, 1,-1,-3, 1, 0,-2,10,-4,-3, 0,-1,-1,-2,-1,-2,-3, 2,-4, 0, 0,-1,-5},
   {-1,-4,-3,-4,-2,-3,-4,-4,-4, 5, 2,-3, 2, 0,-3,-3,-1,-3,-1, 4,-4,-3,-1,-5},
   {-2,-3,-4,-4,-2,-2,-3,-4,-3, 2, 5,-3, 3, 1,-4,-3,-1,-2,-1, 1,-4,-3,-1,-5},
   {-1, 3, 0,-1,-3, 2, 1,-2, 0,-3,-3, 6,-2,-4,-1, 0,-1,-3,-2,-3, 0, 1,-1,-5},
   {-1,-2,-2,-4,-2, 0,-2,-3,-1, 2, 3,-2, 7, 0,-3,-2,-1,-1, 0, 1,-3,-1,-1,-5},
   {-3,-3,-4,-5,-2,-4,-3,-4,-1, 0, 1,-4, 0, 8,-4,-3,-2, 1, 4,-1,-4,-4,-2,-5},
   {-1,-3,-2,-1,-4,-1,-1,-2,-2,-3,-4,-1,-3,-4,10,-1,-1,-4,-3,-3,-2,-1,-2,-5},
   { 1,-1, 1, 0,-1, 0,-1, 0,-1,-3,-3, 0,-2,-3,-1, 5, 2,-4,-2,-2, 0, 0,-1,-5},
   { 0,-1, 0,-1,-1,-1,-1,-2,-2,-1,-1,-1,-1,-2,-1, 2, 5,-3,-2, 0, 0,-1, 0,-5},
   {-3,-3,-4,-5,-5,-1,-3,-3,-3,-3,-2,-3,-1, 1,-4,-4,-3,15, 2,-3,-5,-2,-3,-5},
   {-2,-1,-2,-3,-3,-1,-2,-3, 2,-1,-1,-2, 0, 4,-3,-2,-2, 2, 8,-1,-3,-2,-1,-5},
   { 0,-3,-3,-4,-1,-3,-3,-4,-4, 4, 1,-3, 1,-1,-3,-2, 0,-3,-1, 5,-4,-3,-1,-5},
   {-2,-1, 4, 5,-3, 0, 1,-1, 0,-4,-4, 0,-3,-4,-2, 0, 0,-5,-3,-4, 5, 2,-1,-5},
   {-1, 0, 0, 1,-3, 4, 5,-2, 0,-3,-3, 1,-1,-4,-1, 0,-1,-2,-2,-3, 2, 5,-1,-5},
   {-1,-1,-1,-1,-2,-1,-1,-2,-1,-1,-1,-1,-1,-2,-2,-1, 0,-3,-1,-1,-1,-1,-1,-5},
   {-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5,-5, 1}
};

const int BLOSUM80[24][24] = {
   { 7,-3,-3,-3,-1,-2,-2, 0,-3,-3,-3,-1,-2,-4,-1, 2, 0,-5,-4,-1,-3,-2,-1,-8},
   {-3, 9,-1,-3,-6, 1,-1,-4, 0,-5,-4, 3,-3,-5,-3,-2,-2,-5,-4,-4,-2, 0,-2,-8},
   {-3,-1, 9, 2,-5, 0,-1,-1, 1,-6,-6, 0,-4,-6,-4, 1, 0,-7,-4,-5, 5,-1,-2,-8},
   {-3,-3, 2,10,-7,-1, 2,-3,-2,-7,-7,-2,-6,-6,-3,-1,-2,-8,-6,-6, 6, 1,-3,-8},
   {-1,-6,-5,-7,13,-5,-7,-6,-7,-2,-3,-6,-3,-4,-6,-2,-2,-5,-5,-2,-6,-7,-4,-8},
   {-2, 1, 0,-1,-5, 9, 3,-4, 1,-5,-4, 2,-1,-5,-3,-1,-1,-4,-3,-4,-1, 5,-2,-8},
   {-2,-1,-1, 2,-7, 3, 8,-4, 0,-6,-6, 1,-4,-6,-2,-1,-2,-6,-5,-4, 1, 6,-2,-8},
   { 0,-4,-1,-3,-6,-4,-4, 9,-4,-7,-7,-3,-5,-6,-5,-1,-3,-6,-6,-6,-2,-4,-3,-8},
   {-3, 0, 1,-2,-7, 1, 0,-4,12,-6,-5,-1,-4,-2,-4,-2,-3,-4, 3,-5,-1, 0,-2,-8},
   {-3,-5,-6,-7,-2,-5,-6,-7,-6, 7, 2,-5, 2,-1,-5,-4,-2,-5,-3, 4,-6,-6,-2,-8},
   {-3,-4,-6,-7,-3,-4,-6,-7,-5, 2, 6,-4, 3, 0,-5,-4,-3,-4,-2, 1,-7,-5,-2,-8},
   {-1, 3, 0,-2,-6, 2, 1,-3,-1,-5,-4, 8,-3,-5,-2,-1,-1,-6,-4,-4,-1, 1,-2,-8},
   {-2,-3,-4,-6,-3,-1,-4,-5,-4, 2, 3,-3, 9, 0,-4,-3,-1,-3,-3, 1,-5,-3,-2,-8},
   {-4,-5,-6,-6,-4,-5,-6,-6,-2,-1, 0,-5, 0,10,-6,-4,-4, 0, 4,-2,-6,-6,-3,-8},
   {-1,-3,-4,-3,-6,-3,-2,-5,-4,-5,-5,-2,-4,-6,12,-2,-3,-7,-6,-4,-4,-2,-3,-8},
   { 2,-2, 1,-1,-2,-1,-1,-1,-2,-4,-4,-1,-3,-4,-2, 7, 2,-6,-3,-3, 0,-1,-1,-8},
   { 0,-2, 0,-2,-2,-1,-2,-3,-3,-2,-3,-1,-1,-4,-3, 2, 8,-5,-3, 0,-1,-2,-1,-8},
   {-5,-5,-7,-8,-5,-4,-6,-6,-4,-5,-4,-6,-3, 0,-7,-6,-5,16, 3,-5,-8,-5,-5,-8},
   {-4,-4,-4,-6,-5,-3,-5,-6, 3,-3,-2,-4,-3, 4,-6,-3,-3, 3,11,-3,-5,-4,-3,-8},
   {-1,-4,-5,-6,-2,-4,-4,-6,-5, 4, 1,-4, 1,-2,-4,-3, 0,-5,-3, 7,-6,-4,-2,-8},
   {-3,-2, 5, 6,-6,-1, 1,-2,-1,-6,-7,-1,-5,-6,-4, 0,-1,-8,-5,-6, 6, 0,-3,-8},
   {-2, 0,-1, 1,-7, 5, 6,-4, 0,-6,-5, 1,-3,-6,-2,-1,-2,-5,-4,-4, 0, 6,-2,-8},
   {-1,-2,-2,-3,-4,-2,-2,-3,-2,-2,-2,-2,-2,-3,-3,-1,-1,-5,-3,-2,-3,-2,-2,-8},
   {-8,-8,-8,-8,-8,-8,-8,-8,-8,-8,-8,-8,-8,-8,-8,-8,-8,-8,-8,-8,-8,-8,-8, 1}
};


const int BLOSUM90[24][24] = {
    {5,-2,-2,-3,-1,-1,-1, 0,-2,-2,-2,-1,-2,-3,-1, 1, 0,-4,-3,-1,-2,-1,-1,-6},
    {-2, 6,-1,-3,-5, 1,-1,-3, 0,-4,-3, 2,-2,-4,-3,-1,-2,-4,-3,-3,-2, 0,-2,-6},
    {-2,-1, 7, 1,-4, 0,-1,-1, 0,-4,-4, 0,-3,-4,-3, 0, 0,-5,-3,-4, 4,-1,-2,-6},
    {-3,-3, 1, 7,-5,-1, 1,-2,-2,-5,-5,-1,-4,-5,-3,-1,-2,-6,-4,-5, 4, 0,-2,-6},
    {-1,-5,-4,-5, 9,-4,-6,-4,-5,-2,-2,-4,-2,-3,-4,-2,-2,-4,-4,-2,-4,-5,-3,-6},
    {-1, 1, 0,-1,-4, 7, 2,-3, 1,-4,-3, 1, 0,-4,-2,-1,-1,-3,-3,-3,-1, 4,-1,-6},
    {-1,-1,-1, 1,-6, 2, 6,-3,-1,-4,-4, 0,-3,-5,-2,-1,-1,-5,-4,-3, 0, 4,-2,-6},
    { 0,-3,-1,-2,-4,-3,-3, 6,-3,-5,-5,-2,-4,-5,-3,-1,-3,-4,-5,-5,-2,-3,-2,-6},
    {-2, 0, 0,-2,-5, 1,-1,-3, 8,-4,-4,-1,-3,-2,-3,-2,-2,-3, 1,-4,-1, 0,-2,-6},
    {-2,-4,-4,-5,-2,-4,-4,-5,-4, 5, 1,-4, 1,-1,-4,-3,-1,-4,-2, 3,-5,-4,-2,-6},
    {-2,-3,-4,-5,-2,-3,-4,-5,-4, 1, 5,-3, 2, 0,-4,-3,-2,-3,-2, 0,-5,-4,-2,-6},
    {-1, 2, 0,-1,-4, 1, 0,-2,-1,-4,-3, 6,-2,-4,-2,-1,-1,-5,-3,-3,-1, 1,-1,-6},
    {-2,-2,-3,-4,-2, 0,-3,-4,-3, 1, 2,-2, 7,-1,-3,-2,-1,-2,-2, 0,-4,-2,-1,-6},
    {-3,-4,-4,-5,-3,-4,-5,-5,-2,-1, 0,-4,-1, 7,-4,-3,-3, 0, 3,-2,-4,-4,-2,-6},
    {-1,-3,-3,-3,-4,-2,-2,-3,-3,-4,-4,-2,-3,-4, 8,-2,-2,-5,-4,-3,-3,-2,-2,-6},
    { 1,-1, 0,-1,-2,-1,-1,-1,-2,-3,-3,-1,-2,-3,-2, 5, 1,-4,-3,-2, 0,-1,-1,-6},
    { 0,-2, 0,-2,-2,-1,-1,-3,-2,-1,-2,-1,-1,-3,-2, 1, 6,-4,-2,-1,-1,-1,-1,-6},
    {-4,-4,-5,-6,-4,-3,-5,-4,-3,-4,-3,-5,-2, 0,-5,-4,-4,11, 2,-3,-6,-4,-3,-6},
    {-3,-3,-3,-4,-4,-3,-4,-5, 1,-2,-2,-3,-2, 3,-4,-3,-2, 2, 8,-3,-4,-3,-2,-6},
    {-1,-3,-4,-5,-2,-3,-3,-5,-4, 3, 0,-3, 0,-2,-3,-2,-1,-3,-3, 5,-4,-3,-2,-6},
    {-2,-2, 4, 4,-4,-1, 0,-2,-1,-5,-5,-1,-4,-4,-3, 0,-1,-6,-4,-4, 4, 0,-2,-6},
    {-1, 0,-1, 0,-5, 4, 4,-3, 0,-4,-4, 1,-2,-4,-2,-1,-1,-4,-3,-3, 0, 4,-1,-6},
    {-1,-2,-2,-2,-3,-1,-2,-2,-2,-2,-2,-1,-1,-2,-2,-1,-1,-3,-2,-2,-2,-1,-2,-6},
    {-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6,-6, 1}
};

const int BLOSUM100[24][24] = {
   { 8,-3,-4,-5,-2,-2,-3,-1,-4,-4,-4,-2,-3,-5,-2, 1,-1,-6,-5,-2,-4,-2,-2,-10},
   {-3,10,-2,-5,-8, 0,-2,-6,-1,-7,-6, 3,-4,-6,-5,-3,-3,-7,-5,-6,-4,-1,-3,-10},
   {-4,-2,11, 1,-5,-1,-2,-2, 0,-7,-7,-1,-5,-7,-5, 0,-1,-8,-5,-7, 5,-2,-3,-10},
   {-5,-5, 1,10,-8,-2, 2,-4,-3,-8,-8,-3,-8,-8,-5,-2,-4,-10,-7,-8, 6, 0,-4,-10},
   {-2,-8,-5,-8,14,-7,-9,-7,-8,-3,-5,-8,-4,-4,-8,-3,-3,-7,-6,-3,-7,-8,-5,-10},
   {-2, 0,-1,-2,-7,11, 2,-5, 1,-6,-5, 2,-2,-6,-4,-2,-3,-5,-4,-5,-2, 5,-2,-10},
   {-3,-2,-2, 2,-9, 2,10,-6,-2,-7,-7, 0,-5,-8,-4,-2,-3,-8,-7,-5, 0, 7,-3,-10},
   {-1,-6,-2,-4,-7,-5,-6, 9,-6,-9,-8,-5,-7,-8,-6,-2,-5,-7,-8,-8,-3,-5,-4,-10},
   {-4,-1, 0,-3,-8, 1,-2,-6,13,-7,-6,-3,-5,-4,-5,-3,-4,-5, 1,-7,-2,-1,-4,-10},
   {-4,-7,-7,-8,-3,-6,-7,-9,-7, 8, 2,-6, 1,-2,-7,-5,-3,-6,-4, 4,-8,-7,-3,-10},
   {-4,-6,-7,-8,-5,-5,-7,-8,-6, 2, 8,-6, 3, 0,-7,-6,-4,-5,-4, 0,-8,-6,-3,-10},
   {-2, 3,-1,-3,-8, 2, 0,-5,-3,-6,-6,10,-4,-6,-3,-2,-3,-8,-5,-5,-2, 0,-3,-10},
   {-3,-4,-5,-8,-4,-2,-5,-7,-5, 1, 3,-4,12,-1,-5,-4,-2,-4,-5, 0,-7,-4,-3,-10},
   {-5,-6,-7,-8,-4,-6,-8,-8,-4,-2, 0,-6,-1,11,-7,-5,-5, 0, 4,-3,-7,-7,-4,-10},
   {-2,-5,-5,-5,-8,-4,-4,-6,-5,-7,-7,-3,-5,-7,12,-3,-4,-8,-7,-6,-5,-4,-4,-10},
   { 1,-3, 0,-2,-3,-2,-2,-2,-3,-5,-6,-2,-4,-5,-3, 9, 2,-7,-5,-4,-1,-2,-2,-10},
   {-1,-3,-1,-4,-3,-3,-3,-5,-4,-3,-4,-3,-2,-5,-4, 2, 9,-7,-5,-1,-2,-3,-2,-10},
   {-6,-7,-8,-10,-7,-5,-8,-7,-5,-6,-5,-8,-4, 0,-8,-7,-7,17, 2,-5,-9,-7,-6,-10},
   {-5,-5,-5,-7,-6,-4,-7,-8, 1,-4,-4,-5,-5, 4,-7,-5,-5, 2,12,-5,-6,-6,-4,-10},
   {-2,-6,-7,-8,-3,-5,-5,-8,-7, 4, 0,-5, 0,-3,-6,-4,-1,-5,-5, 8,-7,-5,-3,-10},
   {-4,-4, 5, 6,-7,-2, 0,-3,-2,-8,-8,-2,-7,-7,-5,-1,-2,-9,-6,-7, 6, 0,-4,-10},
   {-2,-1,-2, 0,-8, 5, 7,-5,-1,-7,-6, 0,-4,-7,-4,-2,-3,-7,-6,-5, 0, 6,-2,-10},
   {-2,-3,-3,-4,-5,-2,-3,-4,-4,-3,-3,-3,-3,-4,-4,-2,-2,-6,-4,-3,-4,-2,-3,-10},
   {-10,-10,-10,-10,-10,-10,-10,-10,-10,-10,-10,-10,-10,-10,-10,-10,-10,-10,-10,-10,-10,-10,-10,1}
};


// Updated selection function
const int (*getSubstitutionMatrix(std::string matrixName))[24] {
    if (matrixName == "BLOSUM62") {
        return BLOSUM62;
    } else if (matrixName == "BLOSUM50") {
        return BLOSUM50;
    } else if (matrixName == "BLOSUM45") {
        return BLOSUM45;
    } else if (matrixName == "BLOSUM80") {
        return BLOSUM80;
    } else if (matrixName == "BLOSUM90") {
        return BLOSUM90;
    } else if (matrixName == "BLOSUM100") {
        return BLOSUM100;
    } else {
        Rcpp::stop("Invalid substitution matrix name: %s", matrixName);
    }
}

// Needleman-Wunsch algorithm to calculate similarity
double calculate_similarity(const string &sequence1, const string &sequence2,
                            const int substitutionMatrix[24][24],
                            int gapOpen = 10, int gapExt = 4) {
  size_t m = sequence1.size();
  size_t n = sequence2.size();

  // Initialize matrices
  vector<vector<int>> M(m + 1, vector<int>(n + 1, std::numeric_limits<int>::min() / 2));
  vector<vector<int>> Ix(m + 1, vector<int>(n + 1, std::numeric_limits<int>::min() / 2));
  vector<vector<int>> Iy(m + 1, vector<int>(n + 1, std::numeric_limits<int>::min() / 2));
  vector<vector<char>> traceback(m + 1, vector<char>(n + 1, '0'));

  // Initialize first row and column
  M[0][0] = 0;
  Ix[0][0] = Iy[0][0] = std::numeric_limits<int>::min() / 2;
  for (size_t i = 1; i <= m; ++i) {
    M[i][0] = std::numeric_limits<int>::min() / 2;
    Ix[i][0] = -gapOpen - (i - 1) * gapExt;
    Iy[i][0] = std::numeric_limits<int>::min() / 2;
    traceback[i][0] = 'U'; // Up
  }
  for (size_t j = 1; j <= n; ++j) {
    M[0][j] = std::numeric_limits<int>::min() / 2;
    Ix[0][j] = std::numeric_limits<int>::min() / 2;
    Iy[0][j] = -gapOpen - (j - 1) * gapExt;
    traceback[0][j] = 'L'; // Left
  }

  // Fill matrices
  for (size_t i = 1; i <= m; ++i) {
    char aa1 = sequence1[i - 1];
    auto it1 = aa_to_index.find(aa1);
    if (it1 == aa_to_index.end()) {
      Rcpp::stop("Invalid amino acid in sequence1: %c", aa1);
    }
    int index1 = it1->second;
    for (size_t j = 1; j <= n; ++j) {
      char aa2 = sequence2[j - 1];
      auto it2 = aa_to_index.find(aa2);
      if (it2 == aa_to_index.end()) {
        Rcpp::stop("Invalid amino acid in sequence2: %c", aa2);
      }
      int index2 = it2->second;
      int score = substitutionMatrix[index1][index2];

      // Compute Ix[i][j]
      int gapOpenX = M[i - 1][j] - (gapOpen + gapExt);
      int gapExtX = Ix[i - 1][j] - gapExt;
      Ix[i][j] = std::max(gapOpenX, gapExtX);

      // Compute Iy[i][j]
      int gapOpenY = M[i][j - 1] - (gapOpen + gapExt);
      int gapExtY = Iy[i][j - 1] - gapExt;
      Iy[i][j] = std::max(gapOpenY, gapExtY);

      // Compute M[i][j]
      int diagM = M[i - 1][j - 1] + score;
      int diagIx = Ix[i - 1][j - 1] + score;
      int diagIy = Iy[i - 1][j - 1] + score;
      M[i][j] = std::max({ diagM, diagIx, diagIy });

      // Traceback
      if (M[i][j] >= Ix[i][j] && M[i][j] >= Iy[i][j]) {
        traceback[i][j] = 'D'; // Diagonal
      } else if (Ix[i][j] >= Iy[i][j]) {
        M[i][j] = Ix[i][j];
        traceback[i][j] = 'U'; // Up
      } else {
        M[i][j] = Iy[i][j];
        traceback[i][j] = 'L'; // Left
      }
    }
  }

  // Backtracking to count matches and alignment length
  int matches = 0;
  int alignment_length = 0;
  size_t i = m;
  size_t j = n;

  while (i > 0 || j > 0) {
    char tb = traceback[i][j];
    if (tb == 'D') {
      // Diagonal move
      char a = sequence1[i - 1];
      char b = sequence2[j - 1];
      if (a == b) {
        ++matches;
      }
      --i;
      --j;
    } else if (tb == 'U') {
      // Up move (gap in sequence2)
      --i;
    } else { // 'L'
      // Left move (gap in sequence1)
      --j;
    }
    ++alignment_length;
  }

  // Calculate similarity as number of matches divided by alignment length
  double similarity = static_cast<double>(matches) / alignment_length;
  return similarity;
}

// [[Rcpp::export]]
NumericMatrix calculateSimilarityMatrix(CharacterVector sequences,
                                        std::string matrixName = "BLOSUM62",
                                        int gapOpen = 10, int gapExt = 4) {
  size_t n = sequences.length();
  NumericMatrix similarityMatrix(n, n);

  // Get the substitution matrix
  const int (*substitutionMatrix)[24] = getSubstitutionMatrix(matrixName);
  // Calculate pairwise similarities
  for (size_t i = 0; i < n; ++i) {
    string seq1 = as<string>(sequences[i]);
    for (size_t j = i; j < n; ++j) {
      string seq2 = as<string>(sequences[j]);

      // Get similarity
      double similarity = calculate_similarity(seq1, seq2, substitutionMatrix, gapOpen, gapExt);

      // Assign similarity to matrix
      similarityMatrix(i, j) = similarity;
      similarityMatrix(j, i) = similarity; // Symmetric
    }
  }
  
  // Add dimension names
  // Create numeric labels 1,2,3...
  CharacterVector labels(n);
  for(size_t i = 0; i < n; ++i) {
    labels[i] = std::to_string(i + 1);
  }
  
  // Add dimension names using numeric labels
  similarityMatrix.attr("dimnames") = List::create(labels, labels);
  
  return similarityMatrix;
}

```

```{r}
library(digest)

# Function to generate k-mers from an aligned sequence
generate_kmers = function(sequence, k) {
    kmers = c()
    n = nchar(sequence)
    for (i in 1:(n - k + 1)) {
        kmer = substr(sequence, i, i + k - 1)
        # Skip k-mers containing gaps
        if (!grepl("-", kmer)) {
            kmers = c(kmers, kmer)
        }
    }
    return(unique(kmers))
}

# Function to compute MinHash signature
compute_minhash_signature = function(kmers, num_hashes = 100) {
    signature = numeric(num_hashes)
    universe = unique(kmers)
    for (i in 1:num_hashes) {
        # Use murmur32 algorithm with seed
        hashed_values = sapply(kmers, function(kmer) {
            # Get the hash value as a hexadecimal string
            hash_hex = digest(kmer, algo = "murmur32", seed = i)
            # Convert hexadecimal string to numeric value
            hash_num = as.numeric(paste0("0x", hash_hex))
            return(hash_num)
        })
        signature[i] = min(hashed_values, na.rm = TRUE)
    }
    return(signature)
}

# Function to compute similarity between two signatures
compute_minhash_similarity = function(sig1, sig2) {
    return(sum(sig1 == sig2) / length(sig1))
}

# Function to compute the similarity matrix
compute_similarity_matrix_minhash = function(sequences, k = 3, num_hashes = 100) {
    n = length(sequences)
    similarity_matrix = matrix(0, nrow = n, ncol = n)
    colnames(similarity_matrix) = rownames(similarity_matrix) = sequences

    # Parameters for alignment
    match_score = 1
    mismatch_penalty = -1
    gap_penalty = -1

    # Store MinHash signatures for each sequence
    minhash_signatures = vector("list", n)

    for (i in 1:n) {
        # Align each sequence with itself
        result = needleman_wunsch(sequences[i], sequences[i], match_score, mismatch_penalty, gap_penalty)
        aligned_seq = result$alignment1
        # Generate k-mers
        kmers = generate_kmers(aligned_seq, k)
        # Compute MinHash signature
        minhash_signatures[[i]] = compute_minhash_signature(kmers, num_hashes)
    }

    # Compute pairwise similarities
    for (i in 1:n) {
        for (j in i:n) {
            if (i == j) {
                similarity_matrix[i, j] = 1  # Similarity with itself is 1
            } else {
                sim = compute_minhash_similarity(minhash_signatures[[i]], minhash_signatures[[j]])
                similarity_matrix[i, j] = sim
                similarity_matrix[j, i] = sim
            }
        }
    }
    return(similarity_matrix)
}
```

```{r PSA using existing package}
library(Biostrings)

# Create AAString objects
seq1 <- AAString("TPPPSYETVMAA")
seq2 <- AAString("TPPASYHTVMAA")

# Perform global alignment
alignment <- pairwiseAlignment(seq1, seq2, 
                             type = "global",
                             substitutionMatrix = "BLOSUM45",
                             gapOpening = 10,
                             gapExtension = 4)
alignment

s1 = "RRAVELQTVAFP"
s2 = "PPPSYETVMAAA"
s3 = "TPPPSYETVMAA"
s4 = "TPPASYHTVMAA"
s = c(s1,s2, s3, s4)
# needleman_wunsch_score(s1, s2, matrixName = "BLOSUM45")
calculateSimilarityMatrix(s)
calculateSimilarityMatrix1(s)
```

```{r benchmark}
options(digits = 3)

library(bench)
# Compute the similarity matrix using MinHash
# similarity_matrix_minhash = compute_similarity_matrix_minhash(peptides, k = 3, num_hashes = 100)
# similarity_matrix_minhash[1,]

s = test$sequence[1:100]

# result0 = calculateSimilarityMatrix(s, matrixName = "BLOSUM90") # complex psa
# result1 = minhash_similarity_matrix1(s) # minhash
# result2 = calculateSimilarityMatrix2(s) # simple psa
# 
# result0
# result1
# result2

result = bench::mark(
  calculateSimilarityMatrix(s, matrixName = "BLOSUM62"),
  # calculateSimilarityMatrix1(s),
  minhash_similarity_matrix1(s),
  calculateSimilarityMatrix2(s),
  check = F
)
# 
print(result)
plot(result)


# seq1 <- AAString(s[1])
# seq2 <- AAString(s[2])
# 
# # Perform global alignment
# alignment <- pairwiseAlignment(seq1, seq2, 
#                              type = "global",
#                              substitutionMatrix = "BLOSUM62",
#                              gapOpening = 10,
#                              gapExtension = 4)
# alignment
```

```{r}
s1 = "ATGAGTCTCTCTGATAAGGACAAGGCTGCTGTGAAAGCCCTATGG"
  s2 = "CTGTCTCCTGCCGACAAGACCAACGTCAAGGCCGCCTGGGGTAAG"
s3 = "TGAGTCTCTCTGPTAAGGAUSAGGCTGAGGTGAAAGUCCCTATGG"
match_score = 1
mismatch_penalty = -2
gap_penalty = -2
result = needleman_wunsch(s1, s3, match_score, mismatch_penalty, gap_penalty)

alignment1 = result$alignment1
alignment2 = result$alignment2

# Initialize counters
num_identities <- 0
num_gaps <- 0

# Iterate over sequences
for (i in 1:nchar(alignment1)) {
    char1 <- substr(alignment1, i, i)
    char2 <- substr(alignment2, i, i)
    
    if (char1 == "-" || char2 == "-") {
        num_gaps <- num_gaps + 1
    } else if (char1 == char2) {
        num_identities <- num_identities + 1
    }
}

# Output
nchar(s1)
leng = nchar(alignment1)
cat("Number of identities:", num_identities, "\n")
cat("Number of gaps:", num_gaps, "\n")

alignment1
alignment2

num_identities / leng
```

```{r}
s1 = "RRAVELQTVAFP"
s2 = "PPPSYETVMAAA"
s3 = "TPPPSYETVMAA"
data = read.csv("C:/Users/syl05/OneDrive/Desktop/UMICH/FALL 2024/Biostat 615/DynaAlign/data/testData/Adenovirus_IgG_191213_27Jan2023_MDS_Long_COVID_19_vs_MECFS_Case_Serum.wDescr.sorted.csv")
peptides = data$PROBE_SEQUENCE
mat = calculateSimilarityMatrix(peptides[1:10])
mat
# mat[1,]
mat = minhash_similarity_matrix(peptides[1:10])
mat
# mat[1,]
# calculateSimilarityMatrix(c(s1,s2,s3))
# minhash_similarity_matrix(c(s1,s2,s3))
```

```{Rcpp minhash}
#include <Rcpp.h>
#include <string>
#include <vector>
#include <unordered_set>
#include <algorithm>
// Add OpenMP if available
#ifdef _OPENMP
#include <omp.h>
#endif

using namespace std;
using namespace Rcpp;

// MurmurHash3 implementation
uint32_t murmur3_32(const char* key, size_t len, uint32_t seed) {
    static const uint32_t c1 = 0xcc9e2d51;
    static const uint32_t c2 = 0x1b873593;
    static const uint32_t r1 = 15;
    static const uint32_t r2 = 13;
    static const uint32_t m = 5;
    static const uint32_t n = 0xe6546b64;

    uint32_t hash = seed;

    const int nblocks = len / 4;
    const uint32_t* blocks = (const uint32_t*)(key);

    for(int i = 0; i < nblocks; i++) {
        uint32_t k = blocks[i];
        k *= c1;
        k = (k << r1) | (k >> (32 - r1));
        k *= c2;
        hash ^= k;
        hash = ((hash << r2) | (hash >> (32 - r2))) * m + n;
    }

    const uint8_t* tail = (const uint8_t*)(key + nblocks * 4);
    uint32_t k1 = 0;

    switch(len & 3) {
        case 3: k1 ^= tail[2] << 16;
        case 2: k1 ^= tail[1] << 8;
        case 1: k1 ^= tail[0];
                k1 *= c1;
                k1 = (k1 << r1) | (k1 >> (32 - r1));
                k1 *= c2;
                hash ^= k1;
    }

    hash ^= len;
    hash ^= (hash >> 16);
    hash *= 0x85ebca6b;
    hash ^= (hash >> 13);
    hash *= 0xc2b2ae35;
    hash ^= (hash >> 16);

    return hash;
}

// Hash family class for multiple hash functions
class HashFamily {
private:
    vector<uint32_t> seeds;
    
public:
    HashFamily(int num_hash) {
        seeds.resize(num_hash);
        for(int i = 0; i < num_hash; ++i) {
            seeds[i] = i + 1;  // Simple seed generation
        }
    }
    
    uint32_t hash(const string& s, int index) {
        return murmur3_32(s.c_str(), s.length(), seeds[index]);
    }
};

// Generate k-mers from a sequence
vector<string> generate_kmers(const string& seq, int k) {
    vector<string> kmers;
    if (seq.length() >= k) {
        for(size_t i = 0; i <= seq.length() - k; ++i) {
            kmers.push_back(seq.substr(i, k));
        }
    }
    return kmers;
}

// [[Rcpp::export]]
NumericMatrix minhash_similarity_matrix(CharacterVector sequences, int k = 2, int num_hash = 50) {
    size_t n = sequences.length();
    NumericMatrix similarityMatrix(n, n);
    
    // Initialize hash family
    HashFamily hash_family(num_hash);
    
    // Store signatures for each sequence
    vector<vector<uint32_t>> signatures(n, vector<uint32_t>(num_hash, UINT32_MAX));
    
    // Generate signatures
    for(size_t i = 0; i < n; ++i) {
        string seq = as<string>(sequences[i]);
        vector<string> kmers = generate_kmers(seq, k);
        
        // For each k-mer, update signature
        for(const string& kmer : kmers) {
            for(int h = 0; h < num_hash; ++h) {
                uint32_t hash_value = hash_family.hash(kmer, h);
                signatures[i][h] = min(signatures[i][h], hash_value);
            }
        }
    }
    
    // Calculate similarities
    for(size_t i = 0; i < n; ++i) {
        similarityMatrix(i,i) = 1.0;  // Diagonal elements
        for(size_t j = i+1; j < n; ++j) {
            int matches = 0;
            for(int h = 0; h < num_hash; ++h) {
                if(signatures[i][h] == signatures[j][h]) {
                    ++matches;
                }
            }
            double similarity = static_cast<double>(matches) / num_hash;
            similarityMatrix(i,j) = similarity;
            similarityMatrix(j,i) = similarity;
        }
    }
    
    // Add dimension names (1,2,3...)
    CharacterVector labels(n);
    for(size_t i = 0; i < n; ++i) {
        labels[i] = to_string(i + 1);
    }
    similarityMatrix.attr("dimnames") = List::create(labels, labels);
    
    return similarityMatrix;
}
```

```{Rcpp minhash para}
#include <Rcpp.h>
#include <string>
#include <vector>
#include <unordered_set>
#include <algorithm>
// Add OpenMP if available
#ifdef _OPENMP
#include <omp.h>
#endif

using namespace std;
using namespace Rcpp;

// MurmurHash3 implementation
uint32_t murmur3_32(const char* key, size_t len, uint32_t seed) {
    static const uint32_t c1 = 0xcc9e2d51;
    static const uint32_t c2 = 0x1b873593;
    static const uint32_t r1 = 15;
    static const uint32_t r2 = 13;
    static const uint32_t m = 5;
    static const uint32_t n = 0xe6546b64;

    uint32_t hash = seed;

    const int nblocks = len / 4;
    const uint32_t* blocks = (const uint32_t*)(key);

    for(int i = 0; i < nblocks; i++) {
        uint32_t k = blocks[i];
        k *= c1;
        k = (k << r1) | (k >> (32 - r1));
        k *= c2;
        hash ^= k;
        hash = ((hash << r2) | (hash >> (32 - r2))) * m + n;
    }

    const uint8_t* tail = (const uint8_t*)(key + nblocks * 4);
    uint32_t k1 = 0;

    switch(len & 3) {
        case 3: k1 ^= tail[2] << 16;
        case 2: k1 ^= tail[1] << 8;
        case 1: k1 ^= tail[0];
                k1 *= c1;
                k1 = (k1 << r1) | (k1 >> (32 - r1));
                k1 *= c2;
                hash ^= k1;
    }

    hash ^= len;
    hash ^= (hash >> 16);
    hash *= 0x85ebca6b;
    hash ^= (hash >> 13);
    hash *= 0xc2b2ae35;
    hash ^= (hash >> 16);

    return hash;
}

// Hash family class for multiple hash functions
class HashFamily {
private:
    vector<uint32_t> seeds;
    
public:
    HashFamily(int num_hash) {
        seeds.reserve(num_hash);  // Pre-allocate memory
        // Better seed generation
        for(int i = 0; i < num_hash; ++i) {
            seeds.push_back(murmur3_32((char*)&i, sizeof(i), 0x9747b28c));
        }
    }
    
    uint32_t hash(const string& s, int index) const {  // Made const
        return murmur3_32(s.c_str(), s.length(), seeds[index]);
    }
};

// Improved k-mer generation with pre-allocation
inline vector<string> generate_kmers(const string& seq, int k) {
    vector<string> kmers;
    size_t expected_size = seq.length() - k + 1;
    kmers.reserve(expected_size);  // Pre-allocate memory
    
    for(size_t i = 0; i <= seq.length() - k; ++i) {
        kmers.push_back(seq.substr(i, k));
    }
    return kmers;
}

// [[Rcpp::export]]
NumericMatrix minhash_similarity_matrix1(CharacterVector sequences, int k = 3, int num_hash = 50) {
    size_t n = sequences.length();
    NumericMatrix similarityMatrix(n, n);
    
    // Initialize hash family
    const HashFamily hash_family(num_hash);  // Made const
    
    // Pre-allocate memory for all signatures
    vector<vector<uint32_t>> signatures(n);
    for(auto& sig : signatures) {
        sig.resize(num_hash, UINT32_MAX);
    }
    
    // Generate signatures in parallel
    #pragma omp parallel for schedule(dynamic) if(n > 1000)
    for(size_t i = 0; i < n; ++i) {
        string seq = as<string>(sequences[i]);
        vector<string> kmers = generate_kmers(seq, k);
        
        // Local signature array for thread safety
        vector<uint32_t>& signature = signatures[i];
        
        for(const string& kmer : kmers) {
            for(int h = 0; h < num_hash; ++h) {
                uint32_t hash_value = hash_family.hash(kmer, h);
                signature[h] = min(signature[h], hash_value);
            }
        }
    }
    
    // Calculate similarities in parallel
    #pragma omp parallel for schedule(dynamic) collapse(2) if(n > 1000)
    for(size_t i = 0; i < n; ++i) {
        for(size_t j = i; j < n; ++j) {
            if(i == j) {
                similarityMatrix(i,i) = 1.0;
                continue;
            }
            
            // SIMD-friendly array comparison
            const vector<uint32_t>& sig1 = signatures[i];
            const vector<uint32_t>& sig2 = signatures[j];
            
            int matches = 0;
            for(int h = 0; h < num_hash; ++h) {
                matches += (sig1[h] == sig2[h]);
            }
            
            double similarity = static_cast<double>(matches) / num_hash;
            similarityMatrix(i,j) = similarity;
            similarityMatrix(j,i) = similarity;
        }
    }
    
    // Add dimension names
    CharacterVector labels(n);
    for(size_t i = 0; i < n; ++i) {
        labels[i] = to_string(i + 1);
    }
    similarityMatrix.attr("dimnames") = List::create(labels, labels);
    
    return similarityMatrix;
}
```

```{r}
# Input peptide sequences
peptides <- c(
  s1 = "RRAVELQTVAFP",
  s2 = "RAVELQTVAFPA",
  s3 = "RCVVAFPAVELB"
)
data = read.csv("C:/Users/syl05/OneDrive/Desktop/UMICH/FALL 2024/Biostat 615/DynaAlign/data/testData/Adenovirus_IgG_191213_27Jan2023_MDS_Long_COVID_19_vs_MECFS_Case_Serum.wDescr.sorted.csv")
peptides = data$PROBE_SEQUENCE
peptides = peptides[90:100]
# Function to generate k-mers from a sequence
generate_kmers <- function(sequence, k) {
  n <- nchar(sequence)
  kmers <- substring(sequence, 1:(n - k + 1), k:n)
  return(kmers)
}
# Set the value of k for k-mers
k <- 2  # For example, trigrams

# Generate k-mers for each sequence
all_kmers <- lapply(peptides, generate_kmers, k = k)
# Number of hash functions
num_hashes <- 50  # Adjust as needed for accuracy

# Compute MinHash signatures using the Rcpp function
signatures <- computeMinHashSignatures(all_kmers, num_hashes)
# Function to compute similarity between two signatures
compute_similarity <- function(sig1, sig2) {
  return(mean(sig1 == sig2))
}

# Initialize similarity matrix
num_sequences <- length(peptides)
similarity_matrix <- matrix(0, nrow = num_sequences, ncol = num_sequences)
rownames(similarity_matrix) <- names(peptides)
colnames(similarity_matrix) <- names(peptides)

# Compute pairwise similarities
for (i in 1:num_sequences) {
  for (j in i:num_sequences) {
    sim <- compute_similarity(signatures[[i]], signatures[[j]])
    similarity_matrix[i, j] <- sim
    similarity_matrix[j, i] <- sim  # Symmetric matrix
  }
}

# # View the similarity matrix
# print(similarity_matrix)
similarity_matrix
```

```{r}
similarity_matrix[1,]
```

```{r}
library(bench)
get_minhash_similarity <- function(sequences, k = 2, num_hash = 50, batch_size = NULL) {
    if(!is.character(sequences)) {
        stop("Input must be a character vector of sequences")
    }
    
    # Calculate default batch size if not provided
    if(is.null(batch_size)) {
        n <- length(sequences)
        # Conservative batch size based on sequence length
        batch_size <- min(max(floor(n/10), 100), n)
    }
    
    minhash_similarity_matrix2(sequences, k, num_hash, batch_size)
}
# Set number of OpenMP threads
Sys.setenv("OMP_NUM_THREADS" = parallel::detectCores())

# Run with optimizations
minhash_similarity_matrix(peptides[1:10], k=2, num_hash=50)
minhash_similarity_matrix1(peptides[1:10], k=2, num_hash=50)
get_minhash_similarity(peptides[1:10])
result = bench::mark(minhash_similarity_matrix(peptides, k=2, num_hash=50),
            minhash_similarity_matrix1(peptides, k=2, num_hash=50),
            # calculateSimilarityMatrix(peptides),
            iterations=5,
            check=F)
print(result)
plot(result)
```

```{Rcpp}
#include <Rcpp.h>
#include <string>
#include <vector>
#ifdef _OPENMP
#include <omp.h>
#endif

using namespace std;
using namespace Rcpp;

// MurmurHash3 implementation (same as before)
uint32_t murmur3_32(const char* key, size_t len, uint32_t seed) {
    // ... (same as before)
}

class HashFamily {
private:
    vector<uint32_t> seeds;
    
public:
    HashFamily(int num_hash) {
        seeds.reserve(num_hash);
        for(int i = 0; i < num_hash; ++i) {
            seeds.push_back(i + 1);
        }
    }
    
    uint32_t hash(const string& s, int index) const {
        return murmur3_32(s.c_str(), s.length(), seeds[index]);
    }
};

// Process sequences in batches to reduce memory usage
// [[Rcpp::export]]
NumericMatrix minhash_similarity_matrix2(CharacterVector sequences, int k = 2, int num_hash = 50, 
                                      int batch_size = 100) {
    size_t n = sequences.length();
    NumericMatrix similarityMatrix(n, n);
    const HashFamily hash_family(num_hash);
    
    // Process in batches
    for(size_t batch_start = 0; batch_start < n; batch_start += batch_size) {
        size_t batch_end = min(batch_start + batch_size, n);
        size_t current_batch_size = batch_end - batch_start;
        
        // Allocate memory for current batch only
        vector<vector<uint32_t>> batch_signatures(current_batch_size, 
                                                vector<uint32_t>(num_hash, UINT32_MAX));
        
        // Generate signatures for current batch
        #ifdef _OPENMP
        #pragma omp parallel for schedule(static)
        #endif
        for(size_t i = 0; i < current_batch_size; ++i) {
            string seq = as<string>(sequences[batch_start + i]);
            
            // Generate k-mers on the fly instead of storing
            for(size_t pos = 0; pos <= seq.length() - k; ++pos) {
                string kmer = seq.substr(pos, k);
                for(int h = 0; h < num_hash; ++h) {
                    uint32_t hash_value = hash_family.hash(kmer, h);
                    batch_signatures[i][h] = min(batch_signatures[i][h], hash_value);
                }
            }
        }
        
        // Compare current batch with all sequences
        #ifdef _OPENMP
        #pragma omp parallel for schedule(static) collapse(2)
        #endif
        for(size_t i = 0; i < current_batch_size; ++i) {
            for(size_t j = 0; j < n; ++j) {
                size_t global_i = batch_start + i;
                
                // Skip if we've already computed this pair
                if(global_i < j) continue;
                
                if(global_i == j) {
                    similarityMatrix(global_i, j) = 1.0;
                    continue;
                }
                
                // If j is in current batch, use batch_signatures
                if(j >= batch_start && j < batch_end) {
                    size_t local_j = j - batch_start;
                    int matches = 0;
                    for(int h = 0; h < num_hash; ++h) {
                        matches += (batch_signatures[i][h] == batch_signatures[local_j][h]);
                    }
                    double similarity = static_cast<double>(matches) / num_hash;
                    similarityMatrix(global_i, j) = similarity;
                    similarityMatrix(j, global_i) = similarity;
                }
                // If j is in previous batch, we've already computed it
                else if(j < batch_start) {
                    continue;
                }
                // If j is in future batch, compute its signature now
                else {
                    string seq_j = as<string>(sequences[j]);
                    vector<uint32_t> signature_j(num_hash, UINT32_MAX);
                    
                    for(size_t pos = 0; pos <= seq_j.length() - k; ++pos) {
                        string kmer = seq_j.substr(pos, k);
                        for(int h = 0; h < num_hash; ++h) {
                            uint32_t hash_value = hash_family.hash(kmer, h);
                            signature_j[h] = min(signature_j[h], hash_value);
                        }
                    }
                    
                    int matches = 0;
                    for(int h = 0; h < num_hash; ++h) {
                        matches += (batch_signatures[i][h] == signature_j[h]);
                    }
                    double similarity = static_cast<double>(matches) / num_hash;
                    similarityMatrix(global_i, j) = similarity;
                    similarityMatrix(j, global_i) = similarity;
                }
            }
        }
    }
    
    // Add dimension names
    CharacterVector labels(n);
    for(size_t i = 0; i < n; ++i) {
        labels[i] = to_string(i + 1);
    }
    similarityMatrix.attr("dimnames") = List::create(labels, labels);
    
    return similarityMatrix;
}
```


```{r}
library(devtools)
load_all()
```

